## 术语（Terminology）
首先让我们从一些定义开始：Spock能够让你通过一个感兴趣的系统编写一些描述预期功能（属性、切面）
的规范。感兴趣的系统可以是从单个类到整个应用，另外它也通常称为系统规范（SUS），功能的描述从一个
特定的系统规范快照开始；这个快照被称为功能的夹具（fixture）  
以下的章节将引导你整个有Spock规范组成的构建（代码）块，一个典型的规范通常只会使用它们的一部分。
## 导入（Imports）
```groovy
import spock.lang.*
```
spock.lang包下面包含了大部分重要的用于编写规范的类

## 规范（Specification）
```groovy
class MyFirstSpecification extends Specification {
    // fields
    // fixture methods
    // feature methods
    // helper methods
}
```
一个规范（specification）表现为一个继承了spock.lang.Specification的Groovy类。规范的名字
通常和系统或者系统操作描述相关，比如CustomerSpec, H264VideoPlayback，以及ASpaceshipAttackedFromTwoSides
都是合理的规范名称。  
Specification类包含了一些有用的用于编写specification的方法。此外，它通过Spock的Junit运行器Sputnik，去指定
Junit运行specification。得益于Sputnik，Spock specification能在大部分现代Java IDEs和构建构建工具上
运行。  

## 字段（Fields）

```groovy
def obj = new ClassUnderSpecification()
def coll = new Collaborator()
```

实例字段（instance fields）是一个存放属于specification’s fixture的对象的好方式。
一个好的方式是在声明的时候就直接初始化它们。（语义上等同于一开始就在setup()方法初始化它们）
不同feature方法之间的对象拥有的实例字段并不是共享的，相反，每一个feature方法都有它自己的对象。
这样有助于将每个feature方法隔离开，这通常也是我们的一个目标。
```groovy
@Shared res = new VeryExpensiveResource()
```
有时候你需要一个不同方法之间可以共享的对象，比如这个对象的创建成本很高，或者你想要你的feature方法
与其它方法相互作用。为了实现这个目的，可以声明一个@Shared字段。同样的，最好是在（变量）声明的时候
就初始化它。
```groovy
static final PI = 3.141592654
```
静态变量（static fields）只能用于常量，否则共享字段（shared fields）是更可取的，因为它们在共享
方面的语义更加明确。

## 夹具方法（Fixture Methods）
```groovy
def setupSpec() {}      // runs once - before the first feature method
def setup() {}          // runs before every feature method
def cleanup() {}        // runs after every feature method
def cleanupSpec() {}    // runs once - after the last feature method
```
夹具方法（fixture methods）负责设置和清除每一个feature方法（feature method）运行的环境，
通常，为每个feature方法使用新的夹具（fixture）是一个好的选择，这也是setup()和cleanup()方法
的作用。
所有的夹具方法都是可选的。
